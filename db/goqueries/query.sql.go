// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package goqueries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addProductCategoryByIDs = `-- name: AddProductCategoryByIDs :exec
INSERT INTO product_categories (product_id, category_id)
SELECT $1, $2
WHERE NOT EXISTS (
    SELECT 1 FROM product_categories
    WHERE product_id = $1 AND category_id = $2
)
`

type AddProductCategoryByIDsParams struct {
	ProductID  int32
	CategoryID int32
}

func (q *Queries) AddProductCategoryByIDs(ctx context.Context, arg AddProductCategoryByIDsParams) error {
	_, err := q.db.ExecContext(ctx, addProductCategoryByIDs, arg.ProductID, arg.CategoryID)
	return err
}

const countConvByUserConv = `-- name: CountConvByUserConv :one
SELECT count(*)
FROM conversations_users
WHERE user_id = $1 AND conversation_id = $2
`

type CountConvByUserConvParams struct {
	UserID         int32
	ConversationID int32
}

func (q *Queries) CountConvByUserConv(ctx context.Context, arg CountConvByUserConvParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConvByUserConv, arg.UserID, arg.ConversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteCategoryByID = `-- name: DeleteCategoryByID :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategoryByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCategoryByID, id)
	return err
}

const deleteItemsFromBasket = `-- name: DeleteItemsFromBasket :exec
DELETE FROM basket_items bi
WHERE bi.id = $1
`

func (q *Queries) DeleteItemsFromBasket(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteItemsFromBasket, id)
	return err
}

const deleteProductByID = `-- name: DeleteProductByID :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProductByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteProductByID, id)
	return err
}

const deleteProductCategoryByIDs = `-- name: DeleteProductCategoryByIDs :exec
DELETE FROM product_categories
WHERE product_id=$1 and category_id=$2
`

type DeleteProductCategoryByIDsParams struct {
	ProductID  int32
	CategoryID int32
}

func (q *Queries) DeleteProductCategoryByIDs(ctx context.Context, arg DeleteProductCategoryByIDsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductCategoryByIDs, arg.ProductID, arg.CategoryID)
	return err
}

const deleteSpecialByID = `-- name: DeleteSpecialByID :exec
DELETE FROM special
WHERE id = $1
`

func (q *Queries) DeleteSpecialByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSpecialByID, id)
	return err
}

const deleteVariantByID = `-- name: DeleteVariantByID :exec
DELETE FROM product_variants
WHERE id = $1
`

func (q *Queries) DeleteVariantByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteVariantByID, id)
	return err
}

const getBasketItemByBasketItemId = `-- name: GetBasketItemByBasketItemId :one
SELECT bi.id, user_id, product_variant_id, quantity, bi.created_at, updated_at, pv.id, product_id, sku, pv.price, stock_quantity, option_1_value, option_2_value, pv.created_at, p.id, name, description, p.price, p.created_at, special, option_1_name, option_2_name
FROM basket_items bi
         JOIN product_variants pv on pv.id = bi.product_variant_id
         JOIN products p on p.id = pv.product_id
WHERE bi.id = $1
`

type GetBasketItemByBasketItemIdRow struct {
	ID               int32
	UserID           int32
	ProductVariantID int32
	Quantity         int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ID_2             int32
	ProductID        int32
	Sku              string
	Price            int32
	StockQuantity    int32
	Option1Value     string
	Option2Value     string
	CreatedAt_2      sql.NullTime
	ID_3             int32
	Name             string
	Description      string
	Price_2          int32
	CreatedAt_3      sql.NullTime
	Special          sql.NullInt32
	Option1Name      string
	Option2Name      string
}

func (q *Queries) GetBasketItemByBasketItemId(ctx context.Context, id int32) (GetBasketItemByBasketItemIdRow, error) {
	row := q.db.QueryRowContext(ctx, getBasketItemByBasketItemId, id)
	var i GetBasketItemByBasketItemIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.Option1Value,
		&i.Option2Value,
		&i.CreatedAt_2,
		&i.ID_3,
		&i.Name,
		&i.Description,
		&i.Price_2,
		&i.CreatedAt_3,
		&i.Special,
		&i.Option1Name,
		&i.Option2Name,
	)
	return i, err
}

const getBasketItemsByUserEmail = `-- name: GetBasketItemsByUserEmail :many
SELECT bi.id, user_id, product_variant_id, quantity, bi.created_at, updated_at, pv.id, product_id, sku, pv.price, stock_quantity, option_1_value, option_2_value, pv.created_at, p.id, p.name, description, p.price, p.created_at, special, option_1_name, option_2_name, u.id, google_id, email, u.name, avatar_url, u.created_at, role
FROM basket_items bi
         JOIN product_variants pv on pv.id = bi.product_variant_id
         JOIN products p on p.id = pv.product_id
         JOIN users u on u.id = bi.user_id
WHERE u.email = $1
`

type GetBasketItemsByUserEmailRow struct {
	ID               int32
	UserID           int32
	ProductVariantID int32
	Quantity         int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ID_2             int32
	ProductID        int32
	Sku              string
	Price            int32
	StockQuantity    int32
	Option1Value     string
	Option2Value     string
	CreatedAt_2      sql.NullTime
	ID_3             int32
	Name             string
	Description      string
	Price_2          int32
	CreatedAt_3      sql.NullTime
	Special          sql.NullInt32
	Option1Name      string
	Option2Name      string
	ID_4             int32
	GoogleID         string
	Email            string
	Name_2           string
	AvatarUrl        sql.NullString
	CreatedAt_4      sql.NullTime
	Role             int32
}

func (q *Queries) GetBasketItemsByUserEmail(ctx context.Context, email string) ([]GetBasketItemsByUserEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, getBasketItemsByUserEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBasketItemsByUserEmailRow
	for rows.Next() {
		var i GetBasketItemsByUserEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt_2,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.Price_2,
			&i.CreatedAt_3,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
			&i.ID_4,
			&i.GoogleID,
			&i.Email,
			&i.Name_2,
			&i.AvatarUrl,
			&i.CreatedAt_4,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBasketItemsByUserId = `-- name: GetBasketItemsByUserId :many
SELECT bi.id, user_id, product_variant_id, quantity, bi.created_at, updated_at, pv.id, product_id, sku, pv.price, stock_quantity, option_1_value, option_2_value, pv.created_at, p.id, name, description, p.price, p.created_at, special, option_1_name, option_2_name
FROM basket_items bi
         JOIN product_variants pv on pv.id = bi.product_variant_id
         JOIN products p on p.id = pv.product_id
WHERE bi.user_id = $1
`

type GetBasketItemsByUserIdRow struct {
	ID               int32
	UserID           int32
	ProductVariantID int32
	Quantity         int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ID_2             int32
	ProductID        int32
	Sku              string
	Price            int32
	StockQuantity    int32
	Option1Value     string
	Option2Value     string
	CreatedAt_2      sql.NullTime
	ID_3             int32
	Name             string
	Description      string
	Price_2          int32
	CreatedAt_3      sql.NullTime
	Special          sql.NullInt32
	Option1Name      string
	Option2Name      string
}

func (q *Queries) GetBasketItemsByUserId(ctx context.Context, userID int32) ([]GetBasketItemsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getBasketItemsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBasketItemsByUserIdRow
	for rows.Next() {
		var i GetBasketItemsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt_2,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.Price_2,
			&i.CreatedAt_3,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT id, name, description from categories
order by id asc
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesByProductID = `-- name: GetCategoriesByProductID :many
SELECT c.id, c.name, c.description
From categories c
         JOIN product_categories pc on c.id = pc.category_id
WHERE pc.product_id = $1
`

func (q *Queries) GetCategoriesByProductID(ctx context.Context, productID int32) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesFilteredProductID = `-- name: GetCategoriesFilteredProductID :many
SELECT
    c.id, c.name, c.description,
    CASE
        WHEN pc.product_id IS NOT NULL THEN TRUE
        ELSE FALSE
        END AS has_product
FROM categories c
         LEFT JOIN product_categories pc
                   ON c.id = pc.category_id
                       AND pc.product_id = $1
`

type GetCategoriesFilteredProductIDRow struct {
	ID          int32
	Name        string
	Description sql.NullString
	HasProduct  bool
}

func (q *Queries) GetCategoriesFilteredProductID(ctx context.Context, productID int32) ([]GetCategoriesFilteredProductIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesFilteredProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesFilteredProductIDRow
	for rows.Next() {
		var i GetCategoriesFilteredProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.HasProduct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, description from categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int32) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getConversations = `-- name: GetConversations :many
SELECT c.id, c.name, c.order_id, c.created_at
FROM conversations c
`

func (q *Queries) GetConversations(ctx context.Context) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, getConversations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conversation
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrderID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsByUserId = `-- name: GetConversationsByUserId :many
SELECT DISTINCT c.id, c.name, c.order_id, c.created_at
FROM conversations c
         LEFT JOIN conversations_users cu ON cu.conversation_id = c.id
         LEFT JOIN users u ON u.id = cu.user_id
WHERE u.email = $1
`

func (q *Queries) GetConversationsByUserId(ctx context.Context, email string) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, getConversationsByUserId, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conversation
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrderID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavouriteByProductId = `-- name: GetFavouriteByProductId :many
SELECT id, user_id, product_id, created_at, updated_at
FROM favourite_items fi
WHERE fi.product_id = $1 and fi.user_id = $2
`

type GetFavouriteByProductIdParams struct {
	ProductID int32
	UserID    int32
}

func (q *Queries) GetFavouriteByProductId(ctx context.Context, arg GetFavouriteByProductIdParams) ([]FavouriteItem, error) {
	rows, err := q.db.QueryContext(ctx, getFavouriteByProductId, arg.ProductID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FavouriteItem
	for rows.Next() {
		var i FavouriteItem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavouritesById = `-- name: GetFavouritesById :many
SELECT fi.id, user_id, product_id, fi.created_at, updated_at, u.id, google_id, email, u.name, avatar_url, u.created_at, role, p.id, p.name, description, price, p.created_at, special, option_1_name, option_2_name
FROM favourite_items fi
         JOIN users u ON fi.user_id = u.id
         JOIN products p on p.id = fi.product_id
WHERE u.email = $1
`

type GetFavouritesByIdRow struct {
	ID          int32
	UserID      int32
	ProductID   int32
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	ID_2        int32
	GoogleID    string
	Email       string
	Name        string
	AvatarUrl   sql.NullString
	CreatedAt_2 sql.NullTime
	Role        int32
	ID_3        int32
	Name_2      string
	Description string
	Price       int32
	CreatedAt_3 sql.NullTime
	Special     sql.NullInt32
	Option1Name string
	Option2Name string
}

func (q *Queries) GetFavouritesById(ctx context.Context, email string) ([]GetFavouritesByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getFavouritesById, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavouritesByIdRow
	for rows.Next() {
		var i GetFavouritesByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.AvatarUrl,
			&i.CreatedAt_2,
			&i.Role,
			&i.ID_3,
			&i.Name_2,
			&i.Description,
			&i.Price,
			&i.CreatedAt_3,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestShippingByUserId = `-- name: GetLatestShippingByUserId :one
SELECT sh.id, sh.user_id, sh.phone_number, sh.address, sh.house_number, sh.postal_code, sh.city, sh.notes
FROM shippings sh
         JOIN users u on sh.user_id = u.id
WHERE u.email = $1
ORDER BY sh.id desc
LIMIT 1
`

func (q *Queries) GetLatestShippingByUserId(ctx context.Context, email string) (Shipping, error) {
	row := q.db.QueryRowContext(ctx, getLatestShippingByUserId, email)
	var i Shipping
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.HouseNumber,
		&i.PostalCode,
		&i.City,
		&i.Notes,
	)
	return i, err
}

const getMessages = `-- name: GetMessages :many
SELECT cm.id, cm.conversation_id, cm.sender_id, cm.content, cm.created_at, cm.read_at, cm.status, u.email
FROM conversation_messages cm
         JOIN users u on cm.sender_id = u.id
ORDER BY cm.created_at ASC
`

type GetMessagesRow struct {
	ID             int32
	ConversationID int32
	SenderID       int32
	Content        string
	CreatedAt      time.Time
	ReadAt         sql.NullTime
	Status         sql.NullString
	Email          string
}

func (q *Queries) GetMessages(ctx context.Context) ([]GetMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesRow
	for rows.Next() {
		var i GetMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.CreatedAt,
			&i.ReadAt,
			&i.Status,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByConversationId = `-- name: GetMessagesByConversationId :many
SELECT cm.id, cm.conversation_id, cm.sender_id, cm.content, cm.created_at, cm.read_at, cm.status, u.email
FROM conversation_messages cm
         JOIN conversations c ON cm.conversation_id = c.id
         JOIN users u ON cm.sender_id = u.id
WHERE c.id = $1
ORDER BY cm.created_at ASC
`

type GetMessagesByConversationIdRow struct {
	ID             int32
	ConversationID int32
	SenderID       int32
	Content        string
	CreatedAt      time.Time
	ReadAt         sql.NullTime
	Status         sql.NullString
	Email          string
}

func (q *Queries) GetMessagesByConversationId(ctx context.Context, id int32) ([]GetMessagesByConversationIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByConversationId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesByConversationIdRow
	for rows.Next() {
		var i GetMessagesByConversationIdRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.CreatedAt,
			&i.ReadAt,
			&i.Status,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenConversationById = `-- name: GetOpenConversationById :many
SELECT c.id, name, order_id, c.created_at, o.id, user_id, status, total_price, shipping_id, o.created_at, updated_at
FROM conversations c
         JOIN orders o on c.order_id = o.id
WHERE c.order_id = $1 AND o.status != $2
`

type GetOpenConversationByIdParams struct {
	OrderID int32
	Status  string
}

type GetOpenConversationByIdRow struct {
	ID          int32
	Name        string
	OrderID     int32
	CreatedAt   sql.NullTime
	ID_2        int32
	UserID      int32
	Status      string
	TotalPrice  int32
	ShippingID  int32
	CreatedAt_2 sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetOpenConversationById(ctx context.Context, arg GetOpenConversationByIdParams) ([]GetOpenConversationByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getOpenConversationById, arg.OrderID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOpenConversationByIdRow
	for rows.Next() {
		var i GetOpenConversationByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrderID,
			&i.CreatedAt,
			&i.ID_2,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt_2,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
Select id, user_id, status, total_price, shipping_id, created_at, updated_at
From orders
WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalPrice,
		&i.ShippingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT o.id, user_id, status, total_price, shipping_id, o.created_at, updated_at, oi.id, order_id, product_variant_id, quantity, oi.created_at, pv.id, product_id, sku, pv.price, stock_quantity, option_1_value, option_2_value, pv.created_at, p.id, name, description, p.price, p.created_at, special, option_1_name, option_2_name
FROM orders o
         JOIN order_items oi on oi.order_id = o.id
         JOIN product_variants pv on pv.id = oi.product_variant_id
         JOIN products p on p.id = pv.product_id
WHERE o.id = $1
`

type GetOrderItemsByOrderIDRow struct {
	ID               int32
	UserID           int32
	Status           string
	TotalPrice       int32
	ShippingID       int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ID_2             int32
	OrderID          int32
	ProductVariantID int32
	Quantity         int32
	CreatedAt_2      sql.NullTime
	ID_3             int32
	ProductID        int32
	Sku              string
	Price            int32
	StockQuantity    int32
	Option1Value     string
	Option2Value     string
	CreatedAt_3      sql.NullTime
	ID_4             int32
	Name             string
	Description      string
	Price_2          int32
	CreatedAt_4      sql.NullTime
	Special          sql.NullInt32
	Option1Name      string
	Option2Name      string
}

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, id int32) ([]GetOrderItemsByOrderIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsByOrderID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsByOrderIDRow
	for rows.Next() {
		var i GetOrderItemsByOrderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.OrderID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.CreatedAt_2,
			&i.ID_3,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt_3,
			&i.ID_4,
			&i.Name,
			&i.Description,
			&i.Price_2,
			&i.CreatedAt_4,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByUserId = `-- name: GetOrderItemsByUserId :many
SELECT o.id, user_id, status, total_price, shipping_id, o.created_at, updated_at, oi.id, order_id, product_variant_id, quantity, oi.created_at, pv.id, product_id, sku, pv.price, stock_quantity, option_1_value, option_2_value, pv.created_at, p.id, name, description, p.price, p.created_at, special, option_1_name, option_2_name
FROM orders o
         JOIN order_items oi on oi.order_id = o.id
         JOIN product_variants pv on pv.id = oi.product_variant_id
         JOIN products p on p.id = pv.product_id
WHERE o.user_id = $1
`

type GetOrderItemsByUserIdRow struct {
	ID               int32
	UserID           int32
	Status           string
	TotalPrice       int32
	ShippingID       int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ID_2             int32
	OrderID          int32
	ProductVariantID int32
	Quantity         int32
	CreatedAt_2      sql.NullTime
	ID_3             int32
	ProductID        int32
	Sku              string
	Price            int32
	StockQuantity    int32
	Option1Value     string
	Option2Value     string
	CreatedAt_3      sql.NullTime
	ID_4             int32
	Name             string
	Description      string
	Price_2          int32
	CreatedAt_4      sql.NullTime
	Special          sql.NullInt32
	Option1Name      string
	Option2Name      string
}

func (q *Queries) GetOrderItemsByUserId(ctx context.Context, userID int32) ([]GetOrderItemsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsByUserIdRow
	for rows.Next() {
		var i GetOrderItemsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.OrderID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.CreatedAt_2,
			&i.ID_3,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt_3,
			&i.ID_4,
			&i.Name,
			&i.Description,
			&i.Price_2,
			&i.CreatedAt_4,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserId = `-- name: GetOrdersByUserId :many
SELECT id, user_id, status, total_price, shipping_id, created_at, updated_at
FROM orders o
WHERE o.user_id = $1
ORDER BY o.created_at desc
`

func (q *Queries) GetOrdersByUserId(ctx context.Context, userID int32) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersFillUser = `-- name: GetOrdersFillUser :many
SELECT o.id, user_id, status, total_price, shipping_id, o.created_at, updated_at, users.id, google_id, email, name, avatar_url, users.created_at, role
From orders o
         JOIN users on o.user_id = users.id
order by o.id asc
`

type GetOrdersFillUserRow struct {
	ID          int32
	UserID      int32
	Status      string
	TotalPrice  int32
	ShippingID  int32
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	ID_2        int32
	GoogleID    string
	Email       string
	Name        string
	AvatarUrl   sql.NullString
	CreatedAt_2 sql.NullTime
	Role        int32
}

func (q *Queries) GetOrdersFillUser(ctx context.Context) ([]GetOrdersFillUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersFillUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersFillUserRow
	for rows.Next() {
		var i GetOrdersFillUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.AvatarUrl,
			&i.CreatedAt_2,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersFillUserByStatus = `-- name: GetOrdersFillUserByStatus :many
SELECT o.id, user_id, status, total_price, shipping_id, o.created_at, updated_at, users.id, google_id, email, name, avatar_url, users.created_at, role
From orders o
         JOIN users on o.user_id = users.id
WHERE status = $1
order by o.id asc
`

type GetOrdersFillUserByStatusRow struct {
	ID          int32
	UserID      int32
	Status      string
	TotalPrice  int32
	ShippingID  int32
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	ID_2        int32
	GoogleID    string
	Email       string
	Name        string
	AvatarUrl   sql.NullString
	CreatedAt_2 sql.NullTime
	Role        int32
}

func (q *Queries) GetOrdersFillUserByStatus(ctx context.Context, status string) ([]GetOrdersFillUserByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersFillUserByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersFillUserByStatusRow
	for rows.Next() {
		var i GetOrdersFillUserByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.AvatarUrl,
			&i.CreatedAt_2,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersFillUserConvByStatus = `-- name: GetOrdersFillUserConvByStatus :many
SELECT o.id, o.user_id, o.status, o.total_price, o.shipping_id, o.created_at, o.updated_at, u.email, c.id as convId
From orders o
         JOIN users u on o.user_id = u.id
         JOIN conversations c on o.id = c.order_id
WHERE status = $1
order by o.id asc
`

type GetOrdersFillUserConvByStatusRow struct {
	ID         int32
	UserID     int32
	Status     string
	TotalPrice int32
	ShippingID int32
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
	Email      string
	Convid     int32
}

func (q *Queries) GetOrdersFillUserConvByStatus(ctx context.Context, status string) ([]GetOrdersFillUserConvByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersFillUserConvByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersFillUserConvByStatusRow
	for rows.Next() {
		var i GetOrdersFillUserConvByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalPrice,
			&i.ShippingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Convid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT id, name, description, price, created_at, special, option_1_name, option_2_name from products where id = $1
`

func (q *Queries) GetProductById(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.Special,
		&i.Option1Name,
		&i.Option2Name,
	)
	return i, err
}

const getProductCategoriesManyToMany = `-- name: GetProductCategoriesManyToMany :many
SELECT product_id, category_id from product_categories
`

func (q *Queries) GetProductCategoriesManyToMany(ctx context.Context) ([]ProductCategory, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategoriesManyToMany)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCategory
	for rows.Next() {
		var i ProductCategory
		if err := rows.Scan(&i.ProductID, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariantsByProductId = `-- name: GetProductVariantsByProductId :many
SELECT pv.id, pv.product_id, pv.sku, pv.price, pv.stock_quantity, pv.option_1_value, pv.option_2_value, pv.created_at
FROM product_variants pv
         JOIN products p ON pv.product_id = p.id
WHERE p.id = $1
`

func (q *Queries) GetProductVariantsByProductId(ctx context.Context, id int32) ([]ProductVariant, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariantsByProductId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, description, price, created_at, special, option_1_name, option_2_name from products
ORDER BY id
`

func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategoriesAndName = `-- name: GetProductsByCategoriesAndName :many
SELECT p.id, p.name, p.description, p.price, p.created_at, p.special, p.option_1_name, p.option_2_name, s.id, s.name, (fi.product_id IS NOT NULL)::boolean AS "isFavourite"
FROM products p
         LEFT JOIN special s ON p.special = s.id
         LEFT JOIN favourite_items fi
                   ON fi.product_id = p.id AND fi.user_id = $1

WHERE p.name ILIKE '%' || $2 || '%'
  AND (
    array_length($3::int[], 1) IS NULL
        OR EXISTS (
        SELECT 1 FROM product_categories pc
        WHERE pc.product_id = p.id AND pc.category_id = ANY($3::int[])
    )
    )
  AND (
    array_length($4::int[], 1) IS NULL
        OR p.special = ANY($4::int[])
    )
  AND (
    (p.price >= $5::int)
        AND
    (p.price <= $6::int)
    )
ORDER BY p.id
LIMIT $8::int
OFFSET $7::int
`

type GetProductsByCategoriesAndNameParams struct {
	UserID      int32
	NameFilter  sql.NullString
	CategoryIds []int32
	SpecialIds  []int32
	PriceFrom   int32
	PriceTo     int32
	Offsetvar   int32
	Limitvar    int32
}

type GetProductsByCategoriesAndNameRow struct {
	ID          int32
	Name        string
	Description string
	Price       int32
	CreatedAt   sql.NullTime
	Special     sql.NullInt32
	Option1Name string
	Option2Name string
	ID_2        sql.NullInt32
	Name_2      sql.NullString
	IsFavourite bool
}

func (q *Queries) GetProductsByCategoriesAndName(ctx context.Context, arg GetProductsByCategoriesAndNameParams) ([]GetProductsByCategoriesAndNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategoriesAndName,
		arg.UserID,
		arg.NameFilter,
		pq.Array(arg.CategoryIds),
		pq.Array(arg.SpecialIds),
		arg.PriceFrom,
		arg.PriceTo,
		arg.Offsetvar,
		arg.Limitvar,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByCategoriesAndNameRow
	for rows.Next() {
		var i GetProductsByCategoriesAndNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
			&i.ID_2,
			&i.Name_2,
			&i.IsFavourite,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategoryId = `-- name: GetProductsByCategoryId :many
SELECT p.id, p.name, p.description, p.price, p.created_at, p.special, p.option_1_name, p.option_2_name
FROM products p
         JOIN product_categories pc ON p.id = pc.product_id
WHERE pc.category_id = $1
`

func (q *Queries) GetProductsByCategoryId(ctx context.Context, categoryID int32) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategoryId, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsFillUserByProductID = `-- name: GetReviewsFillUserByProductID :many
SELECT r.id, sender_id, product_id, rating, content, r.created_at, u.id, google_id, email, name, avatar_url, u.created_at, role
FROM reviews r
         JOIN users u on r.sender_id = u.id
WHERE r.product_id = $1
`

type GetReviewsFillUserByProductIDRow struct {
	ID          uuid.UUID
	SenderID    int32
	ProductID   int32
	Rating      int32
	Content     string
	CreatedAt   time.Time
	ID_2        int32
	GoogleID    string
	Email       string
	Name        string
	AvatarUrl   sql.NullString
	CreatedAt_2 sql.NullTime
	Role        int32
}

func (q *Queries) GetReviewsFillUserByProductID(ctx context.Context, productID int32) ([]GetReviewsFillUserByProductIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsFillUserByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsFillUserByProductIDRow
	for rows.Next() {
		var i GetReviewsFillUserByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.ProductID,
			&i.Rating,
			&i.Content,
			&i.CreatedAt,
			&i.ID_2,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.AvatarUrl,
			&i.CreatedAt_2,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecial = `-- name: GetSpecial :many
Select id, name
FROM special
`

func (q *Queries) GetSpecial(ctx context.Context) ([]Special, error) {
	rows, err := q.db.QueryContext(ctx, getSpecial)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Special
	for rows.Next() {
		var i Special
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecialByID = `-- name: GetSpecialByID :one
SELECT id, name from special
WHERE id = $1
`

func (q *Queries) GetSpecialByID(ctx context.Context, id int32) (Special, error) {
	row := q.db.QueryRowContext(ctx, getSpecialByID, id)
	var i Special
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, google_id, email, name, avatar_url, created_at, role
FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantById = `-- name: GetVariantById :one
Select id, product_id, sku, price, stock_quantity, option_1_value, option_2_value, created_at
From product_variants
WHERE id = $1
`

func (q *Queries) GetVariantById(ctx context.Context, id int32) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariantById, id)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.Option1Value,
		&i.Option2Value,
		&i.CreatedAt,
	)
	return i, err
}

const getVariantByOptions = `-- name: GetVariantByOptions :one
SELECT pv.id, pv.product_id, pv.sku, pv.price, pv.stock_quantity, pv.option_1_value, pv.option_2_value, pv.created_at
FROM product_variants pv
WHERE product_id = $1
  AND option_1_value = $2
  AND option_2_value = $3
`

type GetVariantByOptionsParams struct {
	ProductID    int32
	Option1Value string
	Option2Value string
}

func (q *Queries) GetVariantByOptions(ctx context.Context, arg GetVariantByOptionsParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariantByOptions, arg.ProductID, arg.Option1Value, arg.Option2Value)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.Option1Value,
		&i.Option2Value,
		&i.CreatedAt,
	)
	return i, err
}

const getVariantsFilledProducts = `-- name: GetVariantsFilledProducts :many
SELECT pv.id, product_id, sku, pv.price, stock_quantity, option_1_value, option_2_value, pv.created_at, p.id, name, description, p.price, p.created_at, special, option_1_name, option_2_name
FROM product_variants pv
         JOin products p on pv.product_id = p.id
order by pv.id asc
`

type GetVariantsFilledProductsRow struct {
	ID            int32
	ProductID     int32
	Sku           string
	Price         int32
	StockQuantity int32
	Option1Value  string
	Option2Value  string
	CreatedAt     sql.NullTime
	ID_2          int32
	Name          string
	Description   string
	Price_2       int32
	CreatedAt_2   sql.NullTime
	Special       sql.NullInt32
	Option1Name   string
	Option2Name   string
}

func (q *Queries) GetVariantsFilledProducts(ctx context.Context) ([]GetVariantsFilledProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getVariantsFilledProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVariantsFilledProductsRow
	for rows.Next() {
		var i GetVariantsFilledProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt,
			&i.ID_2,
			&i.Name,
			&i.Description,
			&i.Price_2,
			&i.CreatedAt_2,
			&i.Special,
			&i.Option1Name,
			&i.Option2Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBasketItem = `-- name: InsertBasketItem :one
INSERT INTO basket_items (user_id, product_variant_id, quantity)
VALUES ($1, $2, $3)
RETURNING id, user_id, product_variant_id, quantity, created_at, updated_at
`

type InsertBasketItemParams struct {
	UserID           int32
	ProductVariantID int32
	Quantity         int32
}

func (q *Queries) InsertBasketItem(ctx context.Context, arg InsertBasketItemParams) (BasketItem, error) {
	row := q.db.QueryRowContext(ctx, insertBasketItem, arg.UserID, arg.ProductVariantID, arg.Quantity)
	var i BasketItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCategory = `-- name: InsertCategory :exec
INSERT INTO categories (name)
VALUES ($1)
`

func (q *Queries) InsertCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, insertCategory, name)
	return err
}

const insertConversation = `-- name: InsertConversation :one
INSERT INTO conversations (name, order_id)
VALUES ($1, $2)
RETURNING id, name, order_id, created_at
`

type InsertConversationParams struct {
	Name    string
	OrderID int32
}

func (q *Queries) InsertConversation(ctx context.Context, arg InsertConversationParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, insertConversation, arg.Name, arg.OrderID)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrderID,
		&i.CreatedAt,
	)
	return i, err
}

const insertConversationUser = `-- name: InsertConversationUser :one
INSERT INTO conversations_users (conversation_id, user_id)
VALUES ($1, $2)
RETURNING id, conversation_id, user_id
`

type InsertConversationUserParams struct {
	ConversationID int32
	UserID         int32
}

func (q *Queries) InsertConversationUser(ctx context.Context, arg InsertConversationUserParams) (ConversationsUser, error) {
	row := q.db.QueryRowContext(ctx, insertConversationUser, arg.ConversationID, arg.UserID)
	var i ConversationsUser
	err := row.Scan(&i.ID, &i.ConversationID, &i.UserID)
	return i, err
}

const insertItemToFavourites = `-- name: InsertItemToFavourites :one
INSERT INTO favourite_items (user_id, product_id)
VALUES ($1, $2)
RETURNING id, user_id, product_id, created_at, updated_at
`

type InsertItemToFavouritesParams struct {
	UserID    int32
	ProductID int32
}

func (q *Queries) InsertItemToFavourites(ctx context.Context, arg InsertItemToFavouritesParams) (FavouriteItem, error) {
	row := q.db.QueryRowContext(ctx, insertItemToFavourites, arg.UserID, arg.ProductID)
	var i FavouriteItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO conversation_messages (conversation_id, sender_id, content)
VALUES ($1, (SELECT id FROM users WHERE email = $2), $3)
RETURNING id, conversation_id, sender_id, content, created_at, read_at, status
`

type InsertMessageParams struct {
	ConversationID int32
	Email          string
	Content        string
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (ConversationMessage, error) {
	row := q.db.QueryRowContext(ctx, insertMessage, arg.ConversationID, arg.Email, arg.Content)
	var i ConversationMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.CreatedAt,
		&i.ReadAt,
		&i.Status,
	)
	return i, err
}

const insertOrder = `-- name: InsertOrder :one
INSERT INTO orders (user_id, total_price, shipping_id)
Values ($1, $2, $3)
RETURNING id, user_id, status, total_price, shipping_id, created_at, updated_at
`

type InsertOrderParams struct {
	UserID     int32
	TotalPrice int32
	ShippingID int32
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, insertOrder, arg.UserID, arg.TotalPrice, arg.ShippingID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalPrice,
		&i.ShippingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertOrderItem = `-- name: InsertOrderItem :one
INSERT INTO order_items (order_id, product_variant_id, quantity)
Values ($1, $2, $3)
RETURNING id, order_id, product_variant_id, quantity, created_at
`

type InsertOrderItemParams struct {
	OrderID          int32
	ProductVariantID int32
	Quantity         int32
}

func (q *Queries) InsertOrderItem(ctx context.Context, arg InsertOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, insertOrderItem, arg.OrderID, arg.ProductVariantID, arg.Quantity)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const insertProduct = `-- name: InsertProduct :exec
INSERT INTO products (name, description, price, option_1_name, option_2_name, special)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertProductParams struct {
	Name        string
	Description string
	Price       int32
	Option1Name string
	Option2Name string
	Special     sql.NullInt32
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) error {
	_, err := q.db.ExecContext(ctx, insertProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Option1Name,
		arg.Option2Name,
		arg.Special,
	)
	return err
}

const insertReview = `-- name: InsertReview :one
INSERT INTO reviews
(sender_id, product_id, rating, content)
VALUES ($1, $2, $3, $4)
returning id, sender_id, product_id, rating, content, created_at
`

type InsertReviewParams struct {
	SenderID  int32
	ProductID int32
	Rating    int32
	Content   string
}

func (q *Queries) InsertReview(ctx context.Context, arg InsertReviewParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, insertReview,
		arg.SenderID,
		arg.ProductID,
		arg.Rating,
		arg.Content,
	)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.ProductID,
		&i.Rating,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const insertShipping = `-- name: InsertShipping :one
INSERT INTO shippings
(user_id, phone_number, address, house_number, postal_code, city, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
returning id, user_id, phone_number, address, house_number, postal_code, city, notes
`

type InsertShippingParams struct {
	UserID      int32
	PhoneNumber string
	Address     string
	HouseNumber string
	PostalCode  string
	City        string
	Notes       string
}

func (q *Queries) InsertShipping(ctx context.Context, arg InsertShippingParams) (Shipping, error) {
	row := q.db.QueryRowContext(ctx, insertShipping,
		arg.UserID,
		arg.PhoneNumber,
		arg.Address,
		arg.HouseNumber,
		arg.PostalCode,
		arg.City,
		arg.Notes,
	)
	var i Shipping
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.HouseNumber,
		&i.PostalCode,
		&i.City,
		&i.Notes,
	)
	return i, err
}

const insertSpecial = `-- name: InsertSpecial :exec
INSERT INTO special (name)
VALUES ($1)
`

func (q *Queries) InsertSpecial(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, insertSpecial, name)
	return err
}

const insertVariant = `-- name: InsertVariant :exec
INSERT INTO product_variants (product_id, sku, price, stock_quantity, option_1_value, option_2_value)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertVariantParams struct {
	ProductID     int32
	Sku           string
	Price         int32
	StockQuantity int32
	Option1Value  string
	Option2Value  string
}

func (q *Queries) InsertVariant(ctx context.Context, arg InsertVariantParams) error {
	_, err := q.db.ExecContext(ctx, insertVariant,
		arg.ProductID,
		arg.Sku,
		arg.Price,
		arg.StockQuantity,
		arg.Option1Value,
		arg.Option2Value,
	)
	return err
}

const productVariantsByProductId = `-- name: ProductVariantsByProductId :many
SELECT pv.id, pv.product_id, pv.sku, pv.price, pv.stock_quantity, pv.option_1_value, pv.option_2_value, pv.created_at
FROM product_variants pv
WHERE pv.product_id = $1
`

func (q *Queries) ProductVariantsByProductId(ctx context.Context, productID int32) ([]ProductVariant, error) {
	rows, err := q.db.QueryContext(ctx, productVariantsByProductId, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Option1Value,
			&i.Option2Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFromBasket = `-- name: RemoveFromBasket :one
DELETE FROM basket_items
WHERE id = $1
RETURNING id, user_id, product_variant_id, quantity, created_at, updated_at
`

func (q *Queries) RemoveFromBasket(ctx context.Context, id int32) (BasketItem, error) {
	row := q.db.QueryRowContext(ctx, removeFromBasket, id)
	var i BasketItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductVariantID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeItemFromFavourites = `-- name: RemoveItemFromFavourites :exec
DELETE FROM favourite_items fi
WHERE fi.product_id = $1 and fi.user_id = $2
`

type RemoveItemFromFavouritesParams struct {
	ProductID int32
	UserID    int32
}

func (q *Queries) RemoveItemFromFavourites(ctx context.Context, arg RemoveItemFromFavouritesParams) error {
	_, err := q.db.ExecContext(ctx, removeItemFromFavourites, arg.ProductID, arg.UserID)
	return err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories
SET
    name = $2
WHERE id = $1
`

type UpdateCategoryParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateCategory, arg.ID, arg.Name)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $2
WHERE id = $1
RETURNING id, user_id, status, total_price, shipping_id, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     int32
	Status string
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalPrice,
		&i.ShippingID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
    name = $2,
    description = $3,
    price = $4,
    option_1_name = $5,
    option_2_name = $6,
    special = $7
WHERE id = $1
`

type UpdateProductParams struct {
	ID          int32
	Name        string
	Description string
	Price       int32
	Option1Name string
	Option2Name string
	Special     sql.NullInt32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Option1Name,
		arg.Option2Name,
		arg.Special,
	)
	return err
}

const updateSpecial = `-- name: UpdateSpecial :exec
UPDATE special
SET
    name = $2
WHERE id = $1
`

type UpdateSpecialParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpdateSpecial(ctx context.Context, arg UpdateSpecialParams) error {
	_, err := q.db.ExecContext(ctx, updateSpecial, arg.ID, arg.Name)
	return err
}

const updateVariant = `-- name: UpdateVariant :exec
UPDATE product_variants
SET
    sku = $2,
    stock_quantity = $3,
    price = $4,
    option_1_value = $5,
    option_2_value = $6
WHERE id = $1
`

type UpdateVariantParams struct {
	ID            int32
	Sku           string
	StockQuantity int32
	Price         int32
	Option1Value  string
	Option2Value  string
}

func (q *Queries) UpdateVariant(ctx context.Context, arg UpdateVariantParams) error {
	_, err := q.db.ExecContext(ctx, updateVariant,
		arg.ID,
		arg.Sku,
		arg.StockQuantity,
		arg.Price,
		arg.Option1Value,
		arg.Option2Value,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (google_id, email, name, avatar_url)
VALUES ($1, $2, $3, $4)
ON CONFLICT (google_id)
    DO UPDATE SET
                  email = EXCLUDED.email,
                  name = EXCLUDED.name,
                  avatar_url = EXCLUDED.avatar_url
RETURNING id, google_id, email, name, avatar_url, created_at, role
`

type UpsertUserParams struct {
	GoogleID  string
	Email     string
	Name      string
	AvatarUrl sql.NullString
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser,
		arg.GoogleID,
		arg.Email,
		arg.Name,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.Role,
	)
	return i, err
}
